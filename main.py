import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

def convert(value):
    if value.isnumeric(): # если строка, к которой применяется функция состоит только из чисел
        value = int(value)# преобразовываем эту строку в целочисленный тип данных (это случай для столбца episodes)
        return value
    elif not value.isalpha():# если строка не состоит только из букв (может содержать и числа)
        new_value = value.replace(",","")# убираем в ней запятые
        if new_value.isnumeric():# если полученное данным образом значение состоит только из цифр (в качестве символов,
            #т. к. это всё ещё строка)
            value = int(new_value)# преобразовываем в int (это случай для столбца Voters)
            return value
    elif value == "?":# если в данных пробел присваиваем строке значение None
        value = None
        return None

def sort_date(value):
    """Функция используется в 8 задании при сортировке аниме по годам. Из всей даты оставляет только год."""
    if len(value) == 10: #если длина полученного значения составляет 10 символов (то-есть это дата в формате pandas)
        return value[:4]# откидываем день и месяц
    else: # если в данных пропуск
        return "-"

def delete(list):
    """Функция для 11 задания. Заменяет весь список содержащимся в нём искомым элементом"""
    if i in list:
        return i


anime = pd.read_csv('anime.csv', delimiter=',')#чтение файла

print(anime.head(10))#первые 10 анимэ

# для того, чтобы вывести корректную информацию о типе данных каждого из столбцов нужно немного с ними поработать
# так как, например, столбцы episodes и voters, содержащие числовые значения, программа с файла читает как строковые
# а в колонке даты выхода, вместо корректного типа datetime64,элементы имеют строковый тип данных
anime["Episodes"] = anime["Episodes"].apply(convert)# метод apply применяет функцию convert (описание функции convert выше)
# к каждому элементу столбца.
anime["Voters"] = anime["Voters"].apply(convert)# также с voters.
anime["Airdate"] = pd.to_datetime(anime["Airdate"], errors="coerce", format="%b %d, %Y", exact=False) # устанавливаем корректный тип
# данных для колонки Airdate и одинаковую форму записи с помощью метода pandas.to_datetime(). Параметр errors принимает
# информацию о том, какое значение присваивается
# в случае, если при преобразовании происходит ошибка (например, представленное значение не укладывается в установленную маску
# в данном случае errors="coerce". Это означает, что в случае ошибки вместо даты в ячейку записывается NaT (что
# означает "дата не определена". Пустое значение).
# параметр format содержит маску, которая указывает, какие элементы строки программа выбирает для формирования даты
# (%b - месяц, записанный сокращённо буквами, %d - день месяца, %Y - год). Благодаря параметру exact=False программа игнорирует
# лишние символы строки, следующе за её частью, предназначенной для маски. (Параметр, который при значении False указывает,
# что точное совпадение всей строки для маски не обязательно. Достаточно иметь подстроку, подходящую по форме под маску.
# так мы игнорируем время выпуска и (JST), проставленные в некоторых ячейках. Их проще откинуть, так как данная информация является излишней).
print("Тип значений колонок и названия:")
print(anime.dtypes)#вывод информации о типах данных

print(f"\nСтолбец 'Episodes': {anime['Episodes'].describe(percentiles=[.25, .75, .90])}")# вывод статистики для каждого столбца,
# содержащего числовые значения, обеспечивает метод describe. Данный метод выводит не только значения перцентилей (перцентили, о которых мы хотим узнать 
# информацию, указаны в параметре percentiles),
# но и min, max, mean, std (где это возможно). Не хватает медианы, которую мы ищем с помощью метода median() в строке ниже.
print("Медиана:", anime["Episodes"].median())
print(f"\nСтолбец 'Voters': {anime['Voters'].describe(percentiles=[.25, .75, .90])}")# И так для всех столбцов, с числовым
# представлением. Кстати, вывожу я это всё с помощью f-строк (так бывает удобнее). Для этого перед началом строки я пишу "f", сообщая,
# что далее введённый в программу текст составляет f-строку. Данный формат записи позволяет мне вставить значение необходимых
# для вывода переменных сразу в предназначенной для вывода текстовой константе
print("Медиана:", anime["Voters"].median())# но так как в данном случае мы выводим не так много переменных в одной
# строке, то можно и привычным спсобом.
print(f"\nСтолбец 'Rating': {anime['Rating'].describe(percentiles=[.25, .75, .90])}")
print("Медиана:", anime["Rating"].median())
print(f"\nСтолбец 'Airdate': {anime['Airdate'].describe(percentiles=[.25, .75, .90])}")
print("Медиана:", anime["Airdate"].median())

print("\n\n'Title':\n", anime["Title"].unique(), "\nКол-во", len(anime["Title"].unique()))# здесь мы находим все
# возможные значения, которые содержатся в колонке с помощью метода unique() и кол-во этих значений с помощью функции len()
print("\n\n'Production':\n", anime["Production"].unique(), "\nКол-во", len(anime["Production"].unique()))
print("\n\n'Source':\n", anime["Source"].unique(), "\nКол-во", len(anime["Source"].unique()))
# далее придётся поступить немного сложнее, т. к. в колонках
# жанра и темы присутствует по несколько значений в одной ячейке.
un = pd.Series(anime["Genre"].str.cat(sep=",").split(","))# В этой строке мы создаём pd.Series на основе следующей колонки:
# колонку с жанром с помощью .str.cat(sep=",") собираем в одну строку, значения которой разделны запятыми и далее разбиваем её на элементы списка
# по запятым с помощью split(",")
print("\n\n'Genre':\n", un.unique(), "\nКол-во", len(un.unique()))# из созданного Series (в котором уже по одному жанру
# на элемент) вытаскиваем уникальные значения
un = pd.Series(anime["Theme"].str.cat(sep=",").split(","))
print("\n\n'Theme':\n", un.unique(), "\nКол-во", len(un.unique()))

anime.columns = list(map(lambda i: "_".join(i.lower().split(" ")), list(anime.columns)))#преобразование названий колонок
# в нижний регистр

plt.plot()
plt.bar(list(anime["production"].value_counts().sort_values(ascending=True).index),list(anime["production"].value_counts().sort_values(ascending=True)))
# в строчке выше мы берём колонку производителей, и с помощью метода .value_counts() создаём series с названиеми всех компаний, которые фигурируют в колонке
# в роли индексов (названий каждой строки), и соответствующих им элементов массива - количеством упоминаний в столбце
# метод .index означает, что мы выбираем массив индексов, а не элементов Series, а ascending=True - сортировка по возрастанию
# в итоге у нас получается столбчатая диаграмма bar с названиями компаний, занимающих ось Ox, и соответствующим им
# количеством упоминаний в оси Oy. Всё это отсортировано по возрастанию
plt.xticks(np.arange(0,len(list(anime["production"].value_counts()))),list(anime["production"].value_counts().sort_values(ascending=True).index),rotation=90)
# Далее настраиваем отображение графика. В строчке выше мы настраиваем ось Ox. Делаем это с помощью plt.xticks() аргументами которого
# являются два массива: первый массив задаёт что-то вроде множества распределённых на оси Ox точек (по сути настраивает интервал меток), которым будут
# соответстввать имена из второго массива (имена меток). Здесь первое множество (точек) задаётся с помощью numpy.arange(), в котором хранятся
# значения от 0 до количества уникальных элементов в столбце производителей (то-есть мы рассматриваем тот же series, созданный
# с помощью value_counts(), описанный выше, превращённый в список. Количество элементов этого списка будет равно количеству производителей).
# второй массив, задающий имена этих точек, создаётся с помощью списка. Список задаётся через тот же самый series названий компании
# отсортированных по возрастанию количества их упоминаний, где индексы - названия компаний, а элементы - кол-во упоминаний. Из него берутся и добавляются
# в список только индексы. rotation=90 обеспечивает поворот надписей на 90 градусов
plt.yticks(np.arange(0,list(anime["production"].value_counts())[0], step=20), np.arange(1,list(anime["production"].value_counts())[0], step=20))
# в строчке выше настраиваем ось Oy. plt.yticks() аналогичен в своей работе plt.xticks(), только работает для оси Oy.
# Здесь множество точек мы задаём с помощью np.arange(), принимающий значения от 0 до наибольшего количества упоминаний какой-то
# компании. (anime["production"].value_counts())[0] равен наибольшему кол-ву упоминаний, так как метод .value_counts(),
# создавая series с количеством упоминаний по умолчанию сортирует его по убыванию своих элементов. и первый элемент - количество
# упоминаний наиболее часто встречающейся компании). step=20 задаёт в этом массиве шаг элементов равный 20. На диаграмме потом
# будет видно, что с таким шагом во всём массиве у нас будет 7 точек и 7 соответствующих значений-наименований, определяемых
# вторым массивом plt.yticks()
# Второй массив - абсолютно такой же, как и первый. Только, опять же, определяет он не размещение точек на оси Oy, а их названия,
# которыми и являются значения этих точек
plt.xlabel("Производители")# названия
plt.ylabel("Кол-во выпущенных") # осей
plt.show()
print("Компания, выпустившая больше всех аниме:", list(anime["production"].value_counts().index)[0])
# здесь при работе в PyCharm может выскочить ошибка, не влияющая на работу программы. Скорее всего она связана с
# тем, что в названии какого-то из анимэ присутствует невидимый pyCharm символ. (ошибка будет называться UserWarning: Glyph 12539)
# если программа при этом продолжает свою работу, просто игнорируйте её

kol_ep = anime["episodes"].value_counts()# тут делаем то же. что и выше с производителями: для каждого количества
# эпизодов (принимаемые за индекс некого Series) определяется частота их упоминания в столбце. Этот series будет носить название kol_ep.
plt.subplot()
plt.title("Кол-во эпизодов")
plt.xlabel("Количество эпизодов")
plt.ylabel("Кол-во аниме")
plt.bar(list(pd.Series(list(kol_ep.index)).apply(str)),list(kol_ep))# столбчатая диаграмма зависимости кол-ва
# эпизодов от частоты их упоминания. Первый аргумент bar (ось Ox) есть список количеств эпизодов, постоенный на основе series:
# к каждому элементу списка индексов заданного kol_ep (list(kol_ep.index)) при помощи метода .apply()
# применяется str, преобразующая каждый элемент в строковый тип данных. Иначе диаграмма, вроде, будет кривой.
# Второй аргумент - список элементов kol_ep (частота, соответствующая каждому кол-ву эпизодов)
plt.xticks(np.arange(0, len(list(kol_ep.index))), list(pd.Series(list(kol_ep.index)).apply(str)), rotation=90)
# здесь необходимо настроить только ось Ox. Множество точек-меток на этой оси задаётся np.arange() как последовательность
# чисел от 0 до числа встречаемых в столбце значений количеств разных эпизодов len(list(kol_ep.index)). Названия этих меток задаются
# списком значений некоторого series, элементами которого являются индексы kol_ep, приведённые к строковому типу данных
# list(kol_ep.index)).apply(str). С помощью rotation=90 задаётся поворот меток на 90 градусов.
plt.show()
print("Чаще всего эпизодов в аниме:", list(anime["episodes"].value_counts().index)[0])

top_sourse = anime["source"].value_counts().head(3)# определяем series из трёх
# наиболее популярных источников. Для этого с помощью .value_counts() на основе anime["source"] построим series
# индексами которого являются ресурсы, а значениями, соответствующими индексам - кол-во их упоминаний. Всё это
# отсортировано по убыванию. Поэтому нам достаточно просто выбрать первые 3 из данного массива через метод .head(3)
plt.subplot()
plt.title("TOP ресурсов аниме")
plt.xlabel("Ресурс")
plt.ylabel("Кол-во аниме")
plt.bar(list(top_sourse.index),list(top_sourse)) # строим диаграмму, в которой на оси Ox расположим индексы нашего series
# (они же названия ресурсов), а на Oy - количество упоминаний
plt.show()

top_theme = pd.Series(anime["theme"].str.cat(sep=",").split(",")).value_counts() # для определения с помощью value_counts()
# частоты упоминания для каждой темы (а они записаны не по одиночке в каждой ячейке) Необходимо создать такой series,
# чтобы в каждой его строчке содержалось по одной теме. Делается это опять же через .str.cat(sep=",").split(",") над колонкой тем. Элементы колонки соединяются в
# одну строку и разделяются запятыми. Мы получаем строку, перечисляющую все темы. Значения в ней повторяются. Сделаем из этого
# список элементов, разбивая строку по запятой (.split(",")).На основе этого списка и создаём series, к которому применим value_counts()
plt.subplot()
plt.title("TOP тем аниме")
plt.xlabel("Тема")
plt.ylabel("Кол-во аниме")
plt.bar(list(top_theme.index),list(top_theme)) # столбчатая диаграмма. Ox - множество индексов top_theme (они же темы)
# Oy - соответствующая им частота
plt.xticks(np.arange(0, len(list(top_theme.index))), list(top_theme.index), rotation=90)
# определяем множество меток на оси Ox (последовательность от 0 до кол-ва тем) и множество названий list(top_theme.index),
# соответствующих меткам (индексы top_theme). Поворот 90 градусов.
plt.show()
print(f"Наиболее популярная тема: {list(top_theme.index)[0]}")

dates = pd.Series(anime['airdate'].apply(str).str.cat(sep=" ").split(" ")).apply(sort_date).value_counts()
# создаём series под именем dates, который хранит отсортированные по кол-ву выпущенных аниме года. Для этого
# каждый элемент anime['airdate'] с помощью apply(str) переведём из типа datetime64 в str. Далее с помощью
# .str.cat(sep=" ") соединим все даты в одну строку. Даты в ней разделены пробелом. С помощью .split(" ") создадим
# из неё список всех встречающихся дат. Этот список возьмем за основу series, к каждому элементу которого
# с помощью метода .apply() применим функцию sort_date, которая описана в самом начале программы среди пользовательских
# функций. К полученному Series применим метод .value_counts() создавая новый series с частотой встречающихся дат
# (количеством анимэ, выпущенных в каждый год) в качестве элементов и годами в качестве индексов. Это и будет наш dates.
dates = dates.drop(axis=0,index="-")# с помощью метода drop() из dates удаляем строку с индексом "-". axis=0 означает,
# что удаление производится по индексу
plt.subplot()
plt.title("TOP дат выпуска аним")
plt.xlabel("Дата")
plt.ylabel("Кол-во аниме")
plt.bar(list(dates.index),list(dates)) # столбчатая диаграмма, показывающая, сколько анимэ было выпущено в каждый год
plt.xticks(np.arange(0, len(list(dates.index))), list(dates.index), rotation=90)
# настраиваем ось Ox. За массив точек расположения меток примем np.arange() от 0 до количества элементов из dates.index.
# Названия меток - индексы массива dates (dates.index)
plt.show()
print(f"Наиболее частая дата: {list(dates.index)[0]}")

rat = anime[["production","rating"]] # создаём новый DataFrame rat, состоящий из двух колонок исходного anime: ["production","rating"]
res = (rat.groupby(pd.Grouper(key="production"))["rating"].mean().reset_index(name="mean"))# с помощью метода groupby()
# группируем элементы столбца production по среднему рейтингу. Как это происходит (скорее всего): pd.Grouper() с помощью параметра key определяет, значения
# какого столбца мы группируем. Далее конструкция rat.groupby(pd.Grouper(key="production"))["rating"].mean() означает,
# что мы группируем значение столбца производителей по среднему рейтингу. То есть мы находим среднее значение всех элементов
# столбца rating, соответствующих какому-то производителю (всех значений из столбца rating, стоящих напротив наименований
# соответствующего производителя из production) и с помощью метода .reset_index(name="mean") составляем новую колонку
# с именем "mean", хранящую средние значения рейтингов для каждого из производителей. В итоге у нас получается Dataframe
# res, состоящий из двух колонок. В первой колонке записаны все производители (уже единожды), а во второй колонке
# напротив каждого производителя записан его средний рейтинг.
print(res)
res1 = res.sort_values(by='mean', ascending=True)# сортируем строки res по возрастанию (ascending=True)
# значений из колонки "mean" (by='mean')
plt.subplot()
plt.title("TOP комп. по рейтингу:")
plt.xlabel("Компания")
plt.ylabel("Рейтинг")
plt.bar(list(res1["production"]),list(res1["mean"]))# строим диаграмму. Ось Ox - значения столбца res1["production"];
# ось Oy - значения столбца res1["mean"]
plt.xticks(np.arange(0, len(list(res1["production"]))), list(res1["production"]), rotation=90)# настраиваем ось Ox:
# расставляем метки в соответствии с последовательностью numpy от 0 до количества производителей (len(list(res1["production"])))
# За имена меток берём названия производителей. поворот надписей на 90 градусов
plt.show()
print("Три самых рейтинговых компании:")
print(res1.head(3))# выводим шапку таблицы res1 из трёх производителей с наибольшим средним рейтингом


list_of_rat = {}# Это словарь, который каждому ключу-интервалу сопоставляет количество производителей с рейтингом из данного интервала
list_of_rat["[0,1)"] = res1["mean"].lt(1).sum() # для интервала "[0,1)" вычисляем количество производителей с рейтингом из этого интервала
# и записываем его как значение словаря, к которому можно получить доступ посредствам ключа "[0,1)".
# как находим количество: суть метода lt(1) кратко можно трактовать как выборку элементов столбца строго меньших 1.
# "res1["mean"].lt(1).sum() означает, что из столбца res1["mean"] рейтингов метод .lt(1) составляет новый series,
# в котором на место значений столбца строго меньших 1 подставляет значения True. В остальных случаях - False. методом .sum()
# получаем количество True-значений (так как True эквивалентно единице, а false - 0, и метод sum(), вычисляющий сумму значений столбца
# вычислит сумму всех единиц
list_of_rat["[1,2)"] = res1["mean"].lt(2).sum()-res1["mean"].lt(1).sum()# далее для всех интервалов вычисляем значение
# следующим образом: res1["mean"].lt({конец текущего интервала}).sum()-res1["mean"].lt({конец предыдущего интервала}).sum()
list_of_rat["[2,3)"] = res1["mean"].lt(3).sum()-res1["mean"].lt(2).sum()
list_of_rat["[3,4)"] = res1["mean"].lt(4).sum()-res1["mean"].lt(3).sum()
list_of_rat["[4,5)"] = res1["mean"].lt(5).sum()-res1["mean"].lt(4).sum()
list_of_rat["[5,6)"] = res1["mean"].lt(6).sum()-res1["mean"].lt(5).sum()
list_of_rat["[6,7)"] = res1["mean"].lt(7).sum()-res1["mean"].lt(6).sum()
list_of_rat["[7,8)"] = res1["mean"].lt(8).sum()-res1["mean"].lt(7).sum()
list_of_rat["[8,9)"] = res1["mean"].lt(9).sum()-res1["mean"].lt(8).sum()
list_of_rat["[9,10)"] = res1["mean"].lt(10).sum()-res1["mean"].lt(9).sum()
ratings_plot = pd.DataFrame.from_dict(list_of_rat,orient="index")# DataFrame.from_dict() означает формирование
# DataFrame из словаря. В данном случае из словаря с именем list_of_rat, где за индексы принимаются ключи словаря (это регулирует параметр orient="index"),
# а за элементы - значения словаря, соответствующие ключам.
plt.subplot()
plt.title("\nРаспределение рейтингов")
plt.xlabel("Интервал рейтинга")
plt.ylabel("Количество компаний")
plt.bar(list(ratings_plot.index),list(ratings_plot[0]))
# строим диаграмму
plt.show()
print(f"Самый большой рейтинг: {ratings_plot.idxmax()[0]}")

korr = anime[["voters","rating","title"]]# korr - новый DataFrame, состоящий из трёх столбцов: ["voters","rating","title"]
korr = korr.sort_values(by='voters', ascending=True)# отсртируем его строки по возрастанию (ascending=True) просмотров (by='voters')
plt.subplot()
plt.title("\nЗависимость просмотров от рейтинга")
plt.xlabel("Просмотры")
plt.ylabel("рейтинг")
plt.plot(anime["voters"],anime["rating"])# создаём график
print(korr)
plt.show()

un = pd.Series(anime["genre"].str.cat(sep=",").split(",")).unique()# составляем series под именем un
# anime["genre"].str.cat(sep=",").split(",") формирует из всех элементов genre единую строку жанров, разделённую запятыми
# и разбивает её на список, ориентируясь на расстановку запятых (.split(","))
# unique() выделяет из Series уникальные элементы таким образом, что в un остаются все жанры, которые только могут быть в колонке genre единожды
anime["genre"] = anime["genre"].str.split(",") #с помощью str применяем метод .split() ко всем элементам столбца, тем самым
# разделяя жанры в каждой ячейке запятыми
rate_ganre = {} # составляем словарь, где ключами будут являться жанры, а значениями, соответствующими ключам - средний рейтинг
# всех аниме, в перечне жанров которых присутствует данный жанр
for i in un: # цикл, проходящий по всем жанрам
    rate = anime["genre"].apply(delete).isin([i, i]) # создаём маску rate. С помощью метода .apply() применяем функцию delete
# к каждому элементу столбца (функция delete описана в начале программы). Тем самым в ячейке остаётся только иcкомый в текущем цикле жанр
# если он в ней был. С помощью метода isin() формируется маска-series, где в каждую ячейку, жанр в которой содержится в списке [i, i]
# (то-есть равен искомому жанру) записывается True. Иначе - False. Эта маска обновляется с каждым новым циклом
# в зависимости от искомого элемента
    print(i, "\n", anime[rate]["genre"])
    rate_ganre[i] = anime[rate]["rating"].mean()# здесь определяется значение словаря, ключь к которому есть искомый
# жанр i. anime[rate]["rating"].mean() означает, что мы применяем маску к колонке "rating" и высчитываем средний рейтинг
# принимая по внимания те значения рейтинга, в строках которых в маске стоит True
plt.subplot()
plt.title("\nЗависимость рейтинга от жанра")
plt.xlabel("жанр")
plt.ylabel("рейтинг")
plt.bar(list(rate_ganre.keys()),list(rate_ganre.values()))# составляем диаграмму, где ось Оx - множество ключей словаря жанров
# list(rate_ganre.keys()), а Оy - множество значений, соответствующих этим ключам (list(rate_ganre.values()))
plt.xticks(np.arange(0, len(un)), list(rate_ganre.keys()), rotation=90)
# настраиваем ось. В качестве точек расположения меток принимаем np.arange() со значениями от 0 до количества жанров.
# В качестве имён меток берём ключи словаря жанров: list(rate_ganre.keys())
plt.show()

# тут то же, только с темой
un = pd.Series(anime["theme"].str.cat(sep=",").split(",")).unique()
anime["theme"] = anime["theme"].str.split(",")
print(anime["theme"])
rate_theme = {}
for i in un:
    rate = anime["theme"].apply(delete).isin([i, i])
    print(i, "\n", anime[rate]["theme"])
    rate_theme[i] = anime[rate]["rating"].mean()
print(rate_theme)
plt.subplot()
plt.title("\nЗависимость рейтинга от темы")
plt.xlabel("тема")
plt.ylabel("рейтинг")
plt.bar(list(rate_theme.keys()),list(rate_theme.values()))
plt.xticks(np.arange(0, len(un)), list(rate_theme.keys()), rotation=90)
plt.show()
